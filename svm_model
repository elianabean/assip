# %%
import os
import sys
import glob
import re
import pandas as pd
import numpy as np
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.optimizers import Adam
from numpy.lib.stride_tricks import sliding_window_view
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from sklearn.svm import SVC
from sklearn import metrics

# %%
dir = "C:/Users/ewang/Downloads/Data_Set_for_Understanding_User_Identification_in_Virtual_Reality_Through_Behavioral_Biometrics_and_the_Effect_of_Body_Normalization"
file_pattern = os.path.join(dir, '*.csv')

data = []

for file_path in glob.glob(file_pattern):
  file_name = os.path.basename(file_path)
  if file_name.startswith('Archery') and 'repetition1.' in file_name and ('p1_' in file_name or 'p2_' in file_name) and 'BothNormalizations' in file_name:
    #print(file_path)
    df = pd.read_csv(file_path)

    data.append(df)

df = pd.concat(data, ignore_index=True)

pd.set_option("display.max_rows", 10)
pd.set_option("display.expand_frame_repr", True)
pd.set_option('display.width', 1000)

print('Shape of the dataset: ' + str(df.shape))
with pd.option_context('display.max_seq_items', None):
    print(df.head())
    print(df.tail())
# %%
def process_data(data, scenario):
  window_size = 10
  step_size = 1
  #split by bowling vs archery
  scenario_data = data[data['Scenario'] == scenario]

  #split by session, training = session 1 and test = session 2
  train_data = scenario_data[scenario_data['study_session'] == 1]
  test_data = scenario_data[scenario_data['study_session'] == 2]
  #test_data = train_data

  def create_windows_and_labels(data):
      X, y = [], []

      tempdata = data.drop(columns=['ParticipantID', 'Scenario', 'study_session', 'repetition', 'HeightNormalization', 'ArmLengthNormalization', 'timestamp_ms', 'phase'])
      X = tempdata.values
      y = data['ParticipantID'].values

      #print(X)

      scaler = StandardScaler()
      X = scaler.fit_transform(X)
      #print(X)

      """for person, person_data in data.groupby(['ParticipantID']):
        for repetition, rep_data in data.groupby(['repetition']):
            print("hi", person, repetition)
            #tempdata = data.drop(columns=['ParticipantID', 'Scenario', 'study_session', 'repetition', 'HeightNormalization', 'ArmLengthNormalization', 'timestamp_ms', 'phase'])
            tempdata = data[['CenterEyeAnchor_pos_X', 'CenterEyeAnchor_pos_Y', 'CenterEyeAnchor_pos_Z']].values
            #windows = sliding_window_view(tempdata, window_shape=(window_size, tempdata.shape[1]))[::step_size]
            #X.extend(windows)
            #y.extend([person[0]-1] * len(windows))
            #X.append(tempdata.flatten())
            y.append(person[0] - 1)"""
      return X, y

  X_train, y_train = create_windows_and_labels(train_data)
  X_test, y_test = create_windows_and_labels(test_data)

  X_train = np.array(X_train)
  #X_train = X_train.reshape(X_train.shape[0], X_train.shape[2], X_train.shape[3])
  y_train = np.array(y_train)
  #y_train = to_categorical(y_train, num_classes=1) #needed for LSTM
  X_test = np.array(X_test)
  #X_test = X_test.reshape(X_test.shape[0], X_test.shape[2], X_test.shape[3])
  y_test = np.array(y_test)
  #y_test = to_categorical(y_test, num_classes=1) #needed for LSTM

  return X_train, y_train, X_test, y_test

for normalization in ['HeightNormalization']: #should update these to include WithoutNormalization and BothNormalizations
  for scenario in ['Archery']:
    print(f"{scenario}, {normalization}")
    X_train, y_train, X_test, y_test = process_data(df, scenario)

    print(f"Training data shape: {X_train.shape}, Labels shape: {y_train.shape}")
    print(f"Testing data shape: {X_test.shape}, Labels shape: {y_test.shape}")

# %%
np.set_printoptions(threshold=sys.maxsize)
print(y_train)
print(X_train)

# %%
svm_model = SVC(kernel='linear')
"""pipe = make_pipeline(StandardScaler(), svm_model)
pipe.fit(X_train, y_train)
pipe.score(X_test, y_test)"""
svm_model.fit(X_train, y_train)

y_pred = svm_model.predict(X_test)
#print(y_test)
#print(y_test_pred)
print("Accuracy:",metrics.accuracy_score(y_test, y_pred))
